#ifndef PDCGM_ENV_H
#define PDCGM_ENV_H

#include "pdcgm_SMatrix.h"

#include<vector>
#include<cmath>
#include <queue>
#include <utility>
#include<iostream>
#include <sys/time.h> 
#include <memory>
#include "lp_solver.h"
class PDCGM_env;

typedef short (*Oracle_function) (double *, double *, PDCGM_env&, void*);

class PDCGM_env {
private:
	void* instance_data;
	std::unique_ptr<ipx::LpSolver> lps;

	int n_vars;
	int n_vars_art;
	int dim;
	int nb_cvxty_constr;
	int n_cuts;

	std::unique_ptr<PDCGM_SMatrix_CW> G {};

	std::vector<double> lambda;		
	std::vector<double> dual_slack;	
	std::vector<double> u;						


	//Bound on the objective function
	double user_obj_LB;
	double user_obj_UB;
	double obj_LB;
	double obj_UB;


	//Bounds on primal variables
	double primal_var_LB_fxd;
	double primal_var_UB_fxd;

	//Bound on dual variables
	std::vector<double> dual_var_LB_fxd;
	std::vector<double> dual_var_UB_fxd;

	double delta;
	double opt_tol;
	double opt_tol_MAX;

	//double last_upprBnd;
	//double last_lowerBnd;
	//double last_rel_gap_cut;

	double degree_of_optimality;

	int MAX_n_columns;
	//int MAX_n_cuts;
	int MAX_n_columns_oracle;
	//int MAX_n_cuts_oracle;
	int MAX_nnz_col;
	int MAX_outer;
	double MAX_cputime;

	double ratio_reduce_matrix;
	//double tolerance_reduce_matrix;
	int last_outer_reduce_matrix;
	//int start_from_reduce_matrix;

	//short WS_strategy;
	//short WS_last;
	short bounds_all_expanded;
	//short change_bounds;
	short answer_type;
	//short reliable_answer;
	//short centrality_value;
	short use_difficult_iters;

	int ncols_last;
	//int extra_call;

	double rel_gap;
	//double rel_gap_real;
	//double rel_gap_last;

	//double abs_diff;
	//double abs_diff_last;
	//double abs_diff_ratio;
	
	int outer;
	//int inner_WS;
	//int inner_query;

	double cputime_CG;
	double cputime_oracle;
	//double cputime_WS;
	double cputime_RMP;

	short verbosity;

	int RMP_modified;

	short column_elimination;

	//INTS *go_to_zero;

public:



	int PDCGM_set_data(
		const int dim,  	            /* number of kept constraints in the RMP */
    	const int nb_cvxty_constr,   /* number of convexity constraints in the RMP */
    	const int max_nnz_col,        /* max_nnz_col: maximum number of nonzeros in a column */
		const int max_ncols_oracle,   /* max_ncols_oracle: maximum number of columns generated by the oracle */
    	const int max_outer,		    /* maximum number of outer iterations */
    	double* u_initial,		/* initial guess of the dual solution (may be a pointer to NULL)  */
    	const std::vector<double>& b,       		/* RHS of each constraint in the RMP */
    	const std::vector<char>& constr_type,      /* type of each constraint (row) in the RMP */
    	const std::vector<double>& lo_box,  		/* lower bound vector of the dual variables in the RMP */
    	const std::vector<double>& up_box,  		/* upper bound vector of the dual variables in the RMP */
    	void   *instance_data); 

	PDCGM_env(): lps{new ipx::LpSolver},G{new PDCGM_SMatrix_CW{}} {};

	//Set functions
	void PDCGM_set_delta(const double delta) {this->delta = delta;}

	void PDCGM_set_degree_of_optimality(const double degree_of_optimality) {this->degree_of_optimality = degree_of_optimality;}

	void PDCGM_set_max_opt_tol(const double opt_tol_max){this->opt_tol_MAX = opt_tol_max;}

	void PDCGM_set_verbosity(const short verbosity){this->verbosity = verbosity;}

	void PDCGM_set_column_elimination(const short flag){this->column_elimination = flag;}

	void PDCGM_set_max_number_columns(const int number_of_columns) {this->MAX_n_columns = number_of_columns;};

	//void PDCGM_set_start_from_reduce_matrix(const int flag){this->start_from_reduce_matrix=flag;};

	void PDCGM_set_use_diff_iters(const int flag){this->use_difficult_iters=flag;};

	void PDCGM_set_max_cputime(const int cputime){this->MAX_cputime=cputime;};

	//void PDCGM_set_centrality_value(const int centrality_value) {this->centrality_value=centrality_value;};

	//void PDCGM_set_WS_strat(const int flag) {this->WS_strategy=flag;};

	void PDCGM_set_ncols_last(const int n){this->ncols_last = n;};

	//void PDCGM_set_rwstat(const int i, const INTS value){this->rwstat[i] = value;};

	void PDCGM_set_rwstat(const int i, const char value){this->G.get()->PDCGM_set_constr_type(i,value);}


	//Get functions

	std::vector<double> PDCGM_get_dual() {return this->u;};

	double PDCGM_get_obj_UB() {return this->obj_UB;};

	double PDCGM_get_obj_LB() {return this->obj_LB;};

	int PDCGM_get_outer() {return this->outer;};

	char PDCGM_get_rwstat(const int i) {return this->G.get()->m_constr_type[i];};

	int PDCGM_get_dim() {return this->dim;};


	//Other functions

	void PDCGM_free(){freePDCGM();};

	void PDCGM_set_dual_box(const double LB, const double UB);

	void PDCGM_get_pointer_to_master_columns(PDCGM_SMatrix_CW& M);

	void PDCGM_get_pointer_to_master_solution(std::vector<double>& lambda);

	int PDCGM_solve_MP(short (*OracleFunction)(double*, double*, PDCGM_env& , void*) );

	int PDCGM_solve_MP_core( Oracle_function ORACLE);

	void freePDCGM();

	int PDCGM_add_columns(PDCGM_SMatrix_CW& M, int* columnLinks);

	void recalculateOptTol();

	void recalculateRelGap();

	int PDCGM_solve_RMP(double* tempUpperBound, double* tempLowerBound);

	void PDCGM_update_primal_bounds();

	void print_SMatrix_CW(const int from=0);

	void PDCGM_print_Matrix(const int from=0);

	int PDCGM_add_dense_columns(const std::vector<double>& columns, const int n_coeff_column, const int n_columns);

	int PDCGM_reduce_coefficient_matrix();

	int PDCGM_set_dual_slacks();

	int PDCGM_remove_columns(const std::vector<int>& indexVec);

	void PDCGM_expand_bounds();


};


/* auxiliary functions */
#define PDCGM_ALLOC(T,n)  (T*) calloc( (n), sizeof(T))
#define PDCGM_REALLOC(V,T,n)  (T*) realloc(V, (  (n)) * ( sizeof(T)))
#define PDCGM_FREE(v)     if(v != NULL) free(v)

#define PDCGM_MAX(A,B)   ((A)>(B)? (A):(B))
#define PDCGM_MIN(A,B)   ((A)<(B)? (A):(B))
#define PDCGM_BIG			  1.0e+50

#define PDCGM_TOL_ZERO 			1.0e-10

/* Returning messages */
#define PDCGM_COMPLETE        0 /* The problem was solved successfully */
#define PDCGM_MEMORY_ERROR    1 /* Error when ALLOCATING MEMORY */
#define PDCGM_ORACLE_ERROR    2 /* Error when calling the oracle function */
#define PDCGM_SOLVERMP_ERROR  3 /* Error when calling the solve_RMP function */
#define PDCGM_NEGATIVE_GAP    4 /* PDCGM has detected an upper bound smaller than the lower bound */
#define PDCGM_INFEASIBLE	  5 /* PDCGM has detected the problem is infeasible */
#define PDCGM_INCOMPLETE	  6 /* PDCGM has stopped before solving the problem successfully */
#define PDCGM_BOUND_CONFLICT  7 /* PDCGM has stopped prematurely because the last lower (upper) bound is 
								   greater (less) than the upper (lower) bound provided as a parameter */
#define PDCGM_INTEGER_EARLY   8 /* An integer solution was found by IPDCGM rounding heuristic and it is optimal */
 
/* Macros used to measure time */
#define PDCGM_TIME_Statement(TOKEN) struct timeval startTime##_##TOKEN, endTime##_##TOKEN; long time_mtime##_##TOKEN, time_seconds##_##TOKEN, time_useconds##_##TOKEN
#define PDCGM_TIME_Start(TOKEN) gettimeofday(&startTime##_##TOKEN, NULL)
#define PDCGM_TIME_Stop(TOKEN) gettimeofday(&endTime##_##TOKEN, NULL); time_seconds##_##TOKEN = endTime##_##TOKEN.tv_sec - startTime##_##TOKEN.tv_sec; time_useconds##_##TOKEN = endTime##_##TOKEN.tv_usec - startTime##_##TOKEN.tv_usec
#define PDCGM_TIME_Output(TOKEN) 0.001 * round( ((time_seconds##_##TOKEN) * 1000 + time_useconds##_##TOKEN/1000.0) )

#endif
