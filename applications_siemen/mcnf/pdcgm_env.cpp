#include "pdcgm_env.h"

int PDCGM_env::PDCGM_set_data(
		const int dim,  	            /* number of kept constraints in the RMP */
    	const int nb_cvxty_constr,   /* number of convexity constraints in the RMP */
    	const int max_nnz_col,        /* max_nnz_col: maximum number of nonzeros in a column */
		const int max_ncols_oracle,   /* max_ncols_oracle: maximum number of columns generated by the oracle */
    	const int max_outer,		    /* maximum number of outer iterations */
    	double* u_initial,		/* initial guess of the dual solution (may be a pointer to NULL)  */
    	const std::vector<double>& b,       		/* RHS of each constraint in the RMP */
    	const std::vector<char>& constr_type,      /* type of each constraint (row) in the RMP */
    	const std::vector<double>& lo_box,  		/* lower bound vector of the dual variables in the RMP */
    	const std::vector<double>& up_box,  		/* upper bound vector of the dual variables in the RMP */
    	void   *instance_data)
   {
	
	//Set initial dimensions of constraint matrix
	this->dim = dim;
	this->nb_cvxty_constr = nb_cvxty_constr;
	this->MAX_nnz_col = max_nnz_col;
	int max_m = dim+nb_cvxty_constr;
	int max_n = 2*(max_m)+1000;
	int max_nz = (int) ceil(0.05*this->MAX_nnz_col*max_n);

	u = std::vector<double>{};
	if(u_initial!=NULL)
	{
		for(int i=0; i<dim+nb_cvxty_constr;++i)
		{
			u.push_back(u_initial[i]);
		}
	}
	//Set constraint matrix
	//std::cout << &G << '\n';
	G.get()->PDCGM_set_SMatrix_CW(max_m,max_n,max_nz);

	//Set RHS and attributes
	G.get()->PDCGM_set_rhs(b);
	G.get()->PDCGM_set_constr_type(constr_type);

	//Set instance data and variables for RMP
	this->instance_data = instance_data;

	//Set number of columns in oracle
	this->MAX_n_columns_oracle = max_ncols_oracle;


	//Set objective 
	this->obj_LB = -PDCGM_BIG;
	this->obj_UB = PDCGM_BIG;

	//Set bounds on dual variables if given
	//If not given, set (-inf,inf)
	if(lo_box.empty())
	{
		G.get()->PDCGM_set_dual_lb(dim,-INFINITY);
		G.get()->PDCGM_set_dual_lb_fxd(dim,-INFINITY);
	}
	else
	{
		G.get()->PDCGM_set_dual_lb(lo_box);
		G.get()->PDCGM_set_dual_lb_fxd(lo_box);
	}
	if(up_box.empty())
	{
		G.get()->PDCGM_set_dual_ub(dim,INFINITY);
		G.get()->PDCGM_set_dual_ub_fxd(dim,INFINITY);
	}
	else
	{
		G.get()->PDCGM_set_dual_ub(up_box);
		G.get()->PDCGM_set_dual_ub_fxd(up_box);
	}




	//this->primal_var_LB_fxd =0.0;
	//this->primal_var_LB.resize(max_n,this->primal_var_LB_fxd);
	//this->primal_var_UB_fxd = PDCGM_BIG;
	//this->primal_var_UB.resize(max_n,this->primal_var_UB_fxd);

	//Set artificial variables
	this->n_vars = 2*dim;
	this->n_vars_art = 2*dim;
	G.get()->PDCGM_add_art_SMatrix_CW(dim);
	//std::cout << this->n_vars << ' ' << this->n_vars_art << '\n';
	assert(this->n_vars==this->n_vars_art);

	//Set default values of parameters
	this->rel_gap = PDCGM_BIG;
	this->degree_of_optimality = 2;
	this->opt_tol_MAX = 1000.0;
	this->opt_tol=10.0;
	this->delta = 1.0e-6;
	this->ratio_reduce_matrix =0.25;
	this->MAX_n_columns= 10;   //CHANGE BACK TO 10000

	this->bounds_all_expanded=1;
	this->column_elimination =1; //CHANGE BACK TO 0
	this->last_outer_reduce_matrix=0;
	this->use_difficult_iters=0;
	//this->centrality_value=1;

	recalculateOptTol();


	//print_SMatrix_CW();

	//Set time variables to zero
	this->cputime_CG =0.0;
	this->cputime_oracle =0.0;
	this->cputime_RMP = 0.0;
	this->MAX_cputime = 10000.0; //Ten thousand

	//Set iter variables
	this->outer =0;
	this->MAX_outer = max_outer;
	//this->go_to_zero = PDCGM_ALLOC(INTS, max_n);
	this->answer_type =0;

	
	return 0;
}

int PDCGM_env::PDCGM_add_dense_columns(const std::vector<double>& columns, const int n_coeff_column, const int n_columns)
{
	ncols_last = n_columns;
	int ret = G.get()->PDCGM_add_dense_columns(columns,n_coeff_column,n_columns);
	n_vars = G.get()->m_n;
	//PDCGM_update_primal_bounds();
	return ret;
}

void PDCGM_env::recalculateRelGap()
{
	rel_gap = PDCGM_MIN(10.0,(obj_UB-obj_LB)/(1+fabs(obj_UB)));
}

void PDCGM_env::recalculateOptTol()
{
	opt_tol = PDCGM_MIN(opt_tol_MAX,rel_gap/degree_of_optimality);
}

/*
void PDCGM_env::PDCGM_set_dual_box(double user_LB, double user_UB)
{
	bounds_all_expanded = 0;

	for(int i=0; i<dim; ++i)
	{
		if(dual_var_LB_fxd[i] < user_LB) dual_var_LB[i]=user_LB;
		else dual_var_LB[i] = PDCGM_MIN(dual_var_LB_fxd[i],0.0);

		if(dual_var_UB_fxd[i]>user_UB) dual_var_UB[i] = user_UB;
		else dual_var_UB[i] = PDCGM_MAX(dual_var_UB_fxd[i],0.0);
	}


}*/


void PDCGM_env::freePDCGM(){
	/*if(rwstat!=NULL) free(rwstat);
	if(L_save!=NULL) free(L_save);
	if(u!=NULL) free(u);
	//if(G!=NULL) G.get()->PDCGM_free_SMatrix_CW();
	if(go_to_zero!=NULL) free(go_to_zero);
	//if(instance_data!=NULL) free(instance_data);
	if(RMP!=NULL) free(RMP);*/
}



int PDCGM_env::PDCGM_solve_MP_core(Oracle_function ORACLE)
{
	this->MAX_n_columns= 20000; //CHANGE TO REMOVE!
	//std::cout << "value of m " << G.get()->m_m << '\n';
	//print_SMatrix_CW();
	int ret;
	double primal_violation =0.0;
	double dual_violation=0.0;
	double tempUB = PDCGM_BIG;
	double tempLB = -PDCGM_BIG;
	PDCGM_TIME_Statement(local);
	PDCGM_TIME_Statement(global);
	PDCGM_TIME_Start(global);


	printf("\n\nCOLUMNS IN PROBLEM %d  MAX COLUMNS %d\n\n",n_vars-n_vars_art, MAX_n_columns);
	if(this->u.size()==0) 
	{
		this->u = std::vector<double>(G.get()->m_m,0);
	}
	else
	{
		PDCGM_TIME_Start(local);
		answer_type = (ORACLE(&primal_violation,&dual_violation,*this,this->instance_data));
		PDCGM_TIME_Stop(local);
		this->cputime_oracle+=PDCGM_TIME_Output(local);

		tempLB = 0;
		std::vector<double> rhs = G.get()->m_rhs;
		for(int i=0; i<dim;++i) tempLB +=rhs[i]*u[i];

		//for(int i=0; i<dim; ++i) std::cout << "i: " << i << "\trhs: " << rhs[i] << "\tu: " << u[i] << '\n';

		//print_SMatrix_CW(0);

		obj_LB = tempLB+dual_violation;

		std::cout << "After initial ORACLE CALL, the lower bound is " << obj_LB << ". The dual violation is " << dual_violation << "answer_type is " <<answer_type<<'\n';
		std::cout << "The UB is " << obj_UB << " and the primal violation is " << primal_violation << '\n';
	}
	do
	{
		++(this->outer);
		if(bounds_all_expanded==0 && this->outer>1)
		{
			//PDCGM_expand_bounds();
		}
		std::cout << "\n\nITERATION " << this->outer << "\n\n";
		PDCGM_TIME_Start(local);
		ret = PDCGM_solve_RMP(&tempUB,&tempLB);
		PDCGM_TIME_Stop(local);
		this->cputime_RMP+=PDCGM_TIME_Output(local);

		printf("\n\nCOLUMNS IN PROBLEM %d  MAX COLUMNS %d\n\n",n_vars-n_vars_art, MAX_n_columns);
		if(column_elimination &&(n_vars-n_vars_art)>MAX_n_columns && outer>last_outer_reduce_matrix+2)
		{
			last_outer_reduce_matrix=outer;
			std::cout << "Uh oh too many columns!";
			//return 0;
			ret = PDCGM_reduce_coefficient_matrix();
			if(ret>0)
			{
				return ret;
			}
			PDCGM_TIME_Start(local);
			ret = PDCGM_solve_RMP(&tempUB,&tempLB);
			PDCGM_TIME_Stop(local);
		}
		this->cputime_RMP+=PDCGM_TIME_Output(local);
		

		std::cout << "TEMP UPPER BOUND " << tempUB << '\n';
		std::cout << "TEMP LOWER BOUND " << tempLB << '\n'; 
		std::cout << "Actual UB " << obj_UB << " answer type " << answer_type << std::endl;

		if(answer_type>0) obj_UB= PDCGM_MIN(obj_UB,tempUB+primal_violation);
		//besttempLB= PDCGM_MAX(besttempLB,tempLB);
		
		/*if(obj_LB-tempLB>delta*tempLB)
		{
			std::cout << "obj_LB error\n";
			std::cout << "number of columns" << (G.get()->m_n) << '\n';
			return 0;
		}*/

		if(obj_LB>obj_UB)
		{
			std::cout <<"ERROR LB>UB";	
			std::cout << "Upper bound " << obj_UB << " from " << tempUB << '\n';
			std::cout << "Lower bound " << obj_LB << " from " << tempLB << '\n';
			return -1;
		}

		recalculateRelGap();
		recalculateOptTol();
		
		//std::cout<<ret << '\n';

		PDCGM_TIME_Start(local);
		answer_type = (ORACLE(&primal_violation,&dual_violation,*this,this->instance_data));
		PDCGM_TIME_Stop(local);
		this->cputime_oracle+=PDCGM_TIME_Output(local);

		std::cout << "Actual UB " << obj_UB << " answer type " << answer_type << std::endl;
		if(answer_type>0) 
		{
			printf("Dual violation %lf",dual_violation);
			obj_LB = PDCGM_MAX(obj_LB, tempLB+dual_violation);
			obj_UB = PDCGM_MIN(obj_UB,tempUB+primal_violation);
		}

		std::cout << "DUAL VIOLATION " << dual_violation << "\n";
		std::cout << "PRIMAL VIOLATION " << primal_violation << '\n';
		std::cout << "LOWER BOUND " << obj_LB << "\n";
		std::cout << "Upper BOUND " << obj_UB << "\n";
		std::cout << "OPT TOL " << opt_tol << '\n'; 
		std::cout << "REL GAP " << rel_gap << "\n";
		
		//double sum = 0.0;
		//for(int i=0; i<G.get()->m_m; ++i) {sum+=rhs[i]*u[i]; std::cout << "sum: " << sum << '\n';}
		//std::cout << "sum: " << sum << '\n';

		PDCGM_TIME_Stop(global);
		this->cputime_CG = PDCGM_TIME_Output(global);

	} while (rel_gap>delta && this->outer<MAX_outer && this->cputime_CG<this->MAX_cputime && this->outer<500); //CHANGE 500 BOUND!!!!

	std::cout << "number of columns" << (G.get()->m_n) << '\n';
	PDCGM_TIME_Stop(global);
	this->cputime_CG = PDCGM_TIME_Output(global);
	
	std::cout << "Numbr of iters " << this->outer << '\n';
	return 0;
}

//Increase size of primal bounds
void PDCGM_env::PDCGM_update_primal_bounds()
{
	n_vars = G.get()->m_n;
	//primal_var_LB.resize(n_vars,primal_var_LB_fxd);
	//primal_var_UB.resize(n_vars, primal_var_UB_fxd);
}

int PDCGM_env::PDCGM_solve_RMP(double* tempObjUpperBound, double* tempObjLowerBound)
{
	int m = G.get()->m_m;
	ipx::Parameters parameters;
	lps.get()->SetParameters(parameters);
	Int errflag = G.get()->loadModel(*(lps.get()));

	if(errflag)
	{
		std::cout << "invalid model (errflag = " <<errflag << ")\n";
		return 1;
	}

	int status = lps.get()->Solve();
	if(status!=IPX_STATUS_solved)
	{
		std::cout << "status : " << status << ','
				  << " errflag: " << lps.get()->GetInfo().errflag << std::endl;
		return 2;
	}

	// Get solver and solution information.
    ipx::Info info = lps.get()->GetInfo();
    std::cout << "Solver performed " << info.iter << " IPM iterations and "
              << info.updates_crossover << " crossover pivots in "
              << info.time_total << " seconds.\n";
			
	double dual[m];
	//std::cout << "m: " << m << '\n';
	lps.get()->GetInteriorSolution(NULL,NULL,NULL,NULL,dual,NULL,NULL);
	//for(int i=0; i<m; ++i) std::cout << dual[i] << '\n';
	//std::cout << "Size u: " << u.size();
	u.clear();
	
	std::copy(dual,dual+m,back_inserter(u));
	//std::cout << "Printing dual variables: \n";
	//for(int i=0; i<m;++i) //std::cout << dual[i] << ' ';
	//std::cout << "\nFinished printing dual variables\n";
	//for(int i=0; i<m;++i) //std::cout << u[i] << ' ';
	//std::cout << '\n';

	*tempObjUpperBound = info.pobjval;
	*tempObjLowerBound = 0.0;

	int i;
	for(i=0; i<m; ++i ) {
		*tempObjLowerBound += G.get()->m_rhs[i]*u[i]; 
		//std::cout << "RHS: " << G.get()->m_rhs[i] << "Dual vector: " << u[i] << '\n';
	}
	//std::cout << "RHS: " << G.get()->m_rhs[i] << "Dual vector: " << u[i] << '\n';

	std::cout << "After solving RMP, the temp upper bound is " << *tempObjUpperBound;
	std::cout << " and the temp lower bound is " << *tempObjLowerBound << '\n';

	return 0;

	/*int difficult_iters=0;
	int ret;
	int presolve=0;
	int m = G.get()->m_m;
	int n = G.get()->m_n;
	int nz = G.get()->m_nz;
	if(this->use_difficult_iters)
	{
		if(m> 1000) difficult_iters = 6;
		else if(m>500) difficult_iters=5;
		else if(m>100) difficult_iters=4;
		else difficult_iters=3;

		if(difficult_iters>this->outer)
		{
			int idigits = PDCGM_MIN(5,difficult_iters - this->outer); //MAGIC NUMBER
			this->opt_tol = pow(10.0,idigits);
		}
	}


	char* rwname = NULL;
	if(!G.get()->m_rwname.empty())rwname = G.get()->m_rwname.data();
	char* clname = NULL;
	if(!G.get()->m_clname.empty()) clname = G.get()->m_clname.data();

	long nzQ=0;
	long lpqp=0;
	double objcon =0.0;
	double* q_diag =0;
	long* qcol_ptr =0;
	INTS   *qrow_ind = 0;
	double* q_coeff = 0;
	long irobj = G.get()->m_m;
	long iolog =0;
	long NewtonEqnMethod=0;

	if(RMP!=NULL)
	{
		free_Pb(RMP);
	}

	presolve =0;


	preproc_Pb(RMP);


	long restart=0;
	double opt_tol_local = this->opt_tol;
	std::cout << "opt tol local" << opt_tol_local <<'\n';
	long iexit =0;
	double errorb;
	double erroru;
	double errorc;
	double asmall;
	double alarge;
	long iter=0;
	/*
	if(opt_tol_local>=1) 
	{
		ret = solve_Pb(RMP, restart,L_save,&opt_tol_local,&iexit,&errorb,&erroru,&errorc,&asmall,&alarge,&iter);
	}
	else
	{
		ret = acpdm_Pb(RMP, restart,L_save,&opt_tol_local,&iexit,&errorb,&erroru,&errorc,&asmall,&alarge,&iter,go_to_zero);
	}
	
	get_dual_solution(this->RMP,this->u);
	long* status = PDCGM_ALLOC(long,1);
	double* obj = PDCGM_ALLOC(double,1);
	std::cout << "n: " << n << std::endl;
	double* primal = PDCGM_ALLOC(double,nz*nz);
	get_opt_solution(this->RMP,status,obj,primal,NULL,NULL,NULL);
	std::cout << "PRIMAL\n";
	for(int i=0; i<n+1; ++i) std::cout << primal[i]<< "\n";
	free(primal);
	*tempObjUpperBound = this->u[m-1];
	std::cout << "After solving RMP, the temp upper bound is " << *tempObjUpperBound;
	*tempObjLowerBound = 0.0;

	for(int i=0; i<m-1; ++i ) {
		*tempObjLowerBound += rhs[i]*u[i]; 
	}
	std::cout << " and the temp lower bound is " << *tempObjLowerBound << '\n';

	//std::cout << "TempObjLowerBound "<< *tempObjLowerBound << '\n';
	//std::cout << "No crashes!\n";
	return ret;*/
}

int PDCGM_env::PDCGM_add_columns(PDCGM_SMatrix_CW& Mnew, int* columnLinks)
{
	ncols_last = Mnew.m_n;
	int columns_added = G.get()->PDCGM_add_SMatrix_CW(Mnew);
	n_vars = G.get()->m_n;
	//PDCGM_update_primal_bounds();
	return columns_added;
}

int PDCGM_env::PDCGM_solve_MP(Oracle_function ORACLE)
{
	//std::cout << this->n_vars << ' ' << this->n_vars_art << '\n';
	//assert(this->n_vars==this->n_vars_art);

    int ret=PDCGM_solve_MP_core(ORACLE);

    return ret;
}

void PDCGM_env::print_SMatrix_CW(const int from)
{
	G.get()->print_SMatrix_CW(from);
}

void PDCGM_env::PDCGM_print_Matrix(const int from)
{
	G.get()->print_SMatrix_CW(from);
}

int PDCGM_env::PDCGM_reduce_coefficient_matrix()
{
	printf("Reached PDCGM_reduce_coefficient_matrix");
	if(PDCGM_set_dual_slacks())
	{
		std::cout << "Memory allocatoin error in PDCGM_reduce_coefficient_matrix\n";
		return PDCGM_MEMORY_ERROR;
	}
	int nc = dual_slack.size();
	int nreduce = nc*ratio_reduce_matrix;
	std::pair<int,int> queueTemp;
	int t=0;
	if(nreduce<=10)
	{
		return -1;
	}
	//std::cout << "Starting column elimination" << std::endl;
	if(nb_cvxty_constr==1)
	{
		std::priority_queue<std::pair<int,int>> pq{};
		for(int i=0; i<nc;++i)
		{
			pq.push(std::make_pair(dual_slack[i],i));
		}
		std::vector<bool> boolVec(nc,true); //True if we keep column
		std::vector<int>  indexVec(nc,-1); //Indices of columns we keep
		while((!pq.empty()) && t<nreduce)
		{
			queueTemp = pq.top();
			pq.pop();
			boolVec[queueTemp.second] = false;
			++t;
		}
		int j=0;
		for(int i=0; i<nc; ++i) 
		{
			if(boolVec[i])
			{
				indexVec[j] = i;
				++j;
			}
		}
		PDCGM_remove_columns(indexVec);
	}
	else
	{
		//assert(0==0 && "Assert reached");
		//std::cout << "more than one convexity constraint\n" << std::endl;
		std::vector<int> n_row(nb_cvxty_constr,0);
		int beg = G.get()->m_clpnts[n_vars_art];
		int end = G.get()->m_clpnts[n_vars];
		int temp;
		int n_var_in_cvxty=0;
		for(int i=beg; i<end;++i)
		{
			temp = G.get()->m_rwnmbs[i]-dim;
			if(temp>=0 && temp<nb_cvxty_constr)
			{
				++n_row[temp];
				++n_var_in_cvxty;
			}
		}
		std::vector<int> n_row_acc;
		n_row_acc.push_back(0);
		for(int i=1; i<nb_cvxty_constr;++i)
		{
			n_row_acc.push_back(n_row_acc[i-1]+n_row[i-1]);
		}
		n_row.clear();
		n_row.resize(nb_cvxty_constr,0);

		std::vector<int> row_columns(n_var_in_cvxty);
		//std::cout << "Created vector row_columns" << std::endl;
		for(int i=n_vars_art; i<n_vars;++i)
		{
			for(int j=G.get()->m_clpnts[i]; j<G.get()->m_clpnts[i+1];++j)
			{
				temp = G.get()->m_rwnmbs[j]-dim;
				if(temp>=0 && temp<nb_cvxty_constr )
				{
					assert(n_row_acc.size()>temp);
		//			std::cout << n_row_acc[temp] << "\t" << n_row[temp] << std::endl;
					row_columns[n_row[temp] + n_row_acc[temp]] = i-n_vars_art;
					++n_row[temp];
				}
			}
		}
		//std::cout << "Finished row columns creation" << std::endl;

		std::vector<bool> boolVec(nc,true);  	//True if we keep the column
		std::vector<int> indexVec(nc,-1);		//Indices of columns we keep
		for(int i=0; i<nb_cvxty_constr-1;++i)
		{
			//std::cout << i << std::endl;
			if(n_row[i]>3) 						//Only delete columns if there are at least four entries in the cvxty constraint
			{
				std::priority_queue<std::pair<int,int>> pq{};
				for(int j=n_row_acc[i]; j<n_row_acc[i+1]; ++j)
				{
					pq.push(std::make_pair(dual_slack[row_columns[j]],row_columns[j]));
				}
				int j=0;
				while(!pq.empty() && j<n_row[i]-3 && j<5)
				{
					queueTemp = pq.top();
					pq.pop();
					boolVec[queueTemp.second] = false;
					++t;
					++j;
				}
			}
		}
		//std::cout << "Surived for loop" << std::endl;
		if(t>10)
		{
			int j=0;
			for(int i=0; i<indexVec.size(); ++i) 
			{
				if(boolVec[i])
				{
					indexVec[j] = i;
					++j;
				}
			}
			PDCGM_remove_columns(indexVec);
		}
		else
		{
			return -1;	
		}
	}
	return 0;
}

int PDCGM_env::PDCGM_set_dual_slacks()
{
	//printf("Start PDCGM_set_dual_slacks"); 	
	double dual_slack_pos[G.get()->m_n];
	double dual_slack_neg[G.get()->m_n];
	dual_slack.clear();
	dual_slack.reserve(n_vars-n_vars_art);
	lps.get()->GetInteriorSolution(NULL,NULL,NULL,NULL,NULL,dual_slack_pos,dual_slack_neg);

	for(int i=n_vars_art; i<n_vars;++i)
	{
		dual_slack.push_back(dual_slack_pos[i] - dual_slack_neg[i]);
	}
	//printf("PDCGM_set_dual_slacks returned safely");
	return 0;
}

int PDCGM_env::PDCGM_remove_columns(const std::vector<int>& indexVec)
{
	std::cout << "Removing columns:\n Before removing columns: " << G.get()->m_n << '\n';
	
	std::unique_ptr<PDCGM_SMatrix_CW> newMatrix{ new PDCGM_SMatrix_CW{}};
	newMatrix.get()->PDCGM_set_SMatrix_CW(G.get()->m_max_m,G.get()->m_max_n,G.get()->m_max_nz);
	newMatrix.get()->eliminate_columns(*(G.get()),indexVec,n_vars_art);
	G = std::move(newMatrix);
	n_vars = G.get()->m_n;
	std::cout << "After removing columns: " << G.get()->m_n << '\n';

	return 0;
}

void PDCGM_env::PDCGM_get_pointer_to_master_columns(PDCGM_SMatrix_CW& M)
{
	//std::cout << "n of copied matrix " << this->G.get()->m_n << std::endl;
	//std::cout << "artificial variables " << n_vars_art << std::endl;
	//std::cout << "n variables " << n_vars << std::endl;
	//(this->G.get())->print_SMatrix_CW();
	M.copy_SMatrix_CW(*(this->G.get()),n_vars_art);
	//std::cout << "n of new Matrix " << M.m_n << std::endl; 
}

/*void PDCGM_env::PDCGM_get_pointer_to_master_solution(std::vector<double>& lambda)
{
	long status;
	double objective;


	lambda.clear();
	//std::cout << n_vars-n_vars_art << std::endl;
	lambda.reserve(n_vars-n_vars_art);
	double* aux_lambda;

	aux_lambda = PDCGM_ALLOC(double,(RMP->ncopy));
	//std::cout << "RMP n copy " << RMP->ncopy << std::endl;
	if(aux_lambda==NULL)
	{
		std::cout << "ERROR allocating memory in PDCGM_get_pointer_to_master_solution\n";
		return;
	}
	else
	{
		get_opt_solution(this->RMP,&status,&objective,aux_lambda,NULL,NULL,NULL);
		//std::cout << "AUXLAMBDA "<< aux_lambda[0] << std::endl;


		if(aux_lambda==NULL)
		{
			std::cout << "Optimal solution is not available yet\n";
			return;
		}
		for(int i=n_vars_art; i<n_vars; ++i)
		{

			lambda.push_back(aux_lambda[i]);
		}
	}
	PDCGM_FREE(aux_lambda);
}*/

/*void PDCGM_env::PDCGM_expand_bounds()
{
	int aux;
	double new_bound,mult1,mult2,mult3;

	if(rel_gap<0.1)
	{
		this->bounds_all_expanded=1;
		G.get()->PDCGM_increase_bounds_art_SMatrix_CW(dim,dual_var_LB_fxd,dual_var_UB_fxd);
		this->obj_UB=PDCGM_BIG;
		this->obj_LB=-PDCGM_BIG;
		for(int i=0; i<dim;++i)
		{
			dual_var_LB[i] = dual_var_LB_fxd[i];
			dual_var_UB[i] = dual_var_UB_fxd[i];
		}
	}
	else
	{
		this->bounds_all_expanded-1;
		if(this->ncols_last<100)
		{
			mult1=1.01;
			mult2=1.1;
			mult3=1.5;
		}
		else
		{
			mult1=1.1;
			mult2=1.5;
			mult3=2.0;
		}

		for(int i=0; i<dim;i++)
		{
			if(dual_var_UB[i]>-PDCGM_TOL_ZERO && dual_var_UB[i] < dual_var_UB_fxd[i])
			{
				if(u[i]> 0.8*dual_var_UB[i]) new_bound = dual_var_UB[i]*mult1;
				else if(u[i] > 0.5*dual_var_UB[i]) new_bound =dual_var_UB[i]*mult2;
				else if(u[i]>0.3*dual_var_UB[i]) new_bound = dual_var_UB[i]*mult3;
				else new_bound = dual_var_UB_fxd[i];

				if(new_bound >dual_var_UB_fxd[i]) new_bound = dual_var_UB_fxd[i];
				else if(new_bound<dual_var_UB_fxd[i]) this->bounds_all_expanded=0;

				aux = 2*i+1;
				G.get()->m_coeff[aux] = new_bound;
				dual_var_UB[i]=new_bound;
				obj_UB = PDCGM_BIG;
			}

			if(dual_var_LB[i]<PDCGM_TOL_ZERO && dual_var_LB[i] > dual_var_LB_fxd[i])
			{
				if(u[i]< 0.8*dual_var_LB[i]) new_bound = dual_var_LB[i]*mult1;
				else if(u[i] < 0.5*dual_var_LB[i]) new_bound =dual_var_LB[i]*mult2;
				else if(u[i]<0.3*dual_var_LB[i]) new_bound = dual_var_LB[i]*mult3;
				else new_bound = dual_var_LB_fxd[i];

				if(new_bound < dual_var_LB_fxd[i]) new_bound = dual_var_LB_fxd[i];
				else if(new_bound<dual_var_LB_fxd[i]) this->bounds_all_expanded=0;

				aux = 2*i+2*dim+1;
				G.get()->m_coeff[aux] = -new_bound;
				dual_var_UB[i]= new_bound;
				obj_UB = PDCGM_BIG;
			}
		}
	}
}*/