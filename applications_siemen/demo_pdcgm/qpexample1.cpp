/*
 *  HOPDM  (Higher Order Primal-Dual Method)
 *  Copyright:     Jacek Gondzio, 1990, 2010.
 *
 *  PDCGM  (Primal-Dual Column Generation Method)
 *  Copyright:     Jacek Gondzio, 1996, 2010.
 *
 *  Using the PDCGM to solve a simple convex problem.
 *
 *  Written by:  - Jacek Gondzio
 *                 Department of Mathematics and Statistics,
 *                 The University of Edinburgh,
 *                 Mayfield Road, King's Buildings.
 *                 EH9 3JZ Edinburgh, Scotland.
 *                 on leave from: Systems Research Institute,
 *                 Polish Academy of Sciences,
 *                 Newelska 6, 01-447 Warsaw, Poland.
 *
 *               - Pedro Munari
 *                 University of Sao Paulo, Brazil
 *                 pedro.munari@gmail.com
 *
 *  Last modified: July, 2012.
 */

/* 
	File: qpexample1.
	It is a complete example of how to use PDCGM as a cutting plane algorithm in
	order to minimize a convex function. In this implementation, the columns are
	sent as dense vectors to PDCGM. No initial columns are suggested to the solver.
	(See files qpexample2.c and qpexample3.c for variations). We strongly recommend 
	reading the following description before going through the code. 
	
	We consider minimizing the function:
      
            f(y) = y*y + 3*y + 1, with -10 <= y <= 10,
    				
    by using a cutting plane strategy. Thus, f(y) is available only 
    through an *oracle* which is in charge of evaluating f(y) for any given
    point y, which is obtained by the *master* problem. 
    
    Given a point y, the oracle must return one of the following alternatives:
    - a feasibility cut, in case y does not belong to a feasible set known 
      only by the oracle. The feasibility cut must separate y from the
      feasible set, so that by imposing this cut in the master problem will
      result in not obtaining the same y again;
    - an optimality cut, in case y is feasible regarding the feasible known 
      only by the oracle. The optimality cut must be a subgradient of f() 
      evaluated at point y;
    
    The cutting plane master problem (CPMP) to be solved is given by

    [CPMP]  min   z,
            
            s.t.  z >= f(y_k) + s(y_k) * (y - y_k), k \in K,

                  0 >= g(y_j) + t(y_j) * (y - y_j), j \in J,

                  -10 <= y <= 10.
	
	where K is the set of optimality cuts generated by the oracle, J is the
	set of feasibility cuts generated by the oracle, s(y_k) is the subgradient
	of f() evaluated at point y_k, t(y_j) is the subdifferential of g() evaluated
	at point y_j. Notice that f(y) is not explicitly available in the CPMP, but
	only the values f(y_k) which are provided by the oracle.
	
	Since PDCGM is a column generation procedure, we need to recast the CPMP 
	as a column generation master problem (CGMP). The CGMP is actually the dual 
	problem of CPMP. To obtain this dual problem, we first write the CPMP as
	
    [CPMP_2]    min   z,
			
                s.t.  z - s(y_k) * y >= f(y_k) - s(y_k) * y_k, k \in K,
			 
                        - t(y_j) * y >= g(y_j) - t(y_j) * y_j, j \in J,
			
                      (y free)
	
	so that all the scalars are now in the RHS of the inequalities. Note that we 
	have also discarded the box constraints -10 <= y <= 10, as PDCGM can easily
	handle them. By defining:
	
            c_k = f(y_k) - s(y_k) * y_k, k \in K, and
			
            d_j = g(y_j) - t(y_j) * y_j, j \in J,
	
	and using x^k and x^j to represent the dual variables associated to the first 
	and second set of constraints, respect., the dual problem of CPMP_2 is given by
			
    [CGMP]  max  c_k * x^k  +  d_j * x^j 
			
            s.t.  s(y_k) * x^k  +  t(y_j) x^j  =  0,       [linking constraint]
             
                       1 * x^k                 =  1,       [convexity constraint]
            
                x^k >= 0,  k \in K,
                 
                x^j >= 0,  j \in J,
                
	which is a column generation master problem, in which the columns are generated
	by the same oracle as mentioned above. Notice that the oracle is still called 
	using the point y, which is now the dual variable of the CGMP. In addition, PDCGM
	assumes the CGMP is a minimization problem and, hence, we restate the objective
	function as 'min -c_k * x^k - d_j * x^j'. (The linking constraints were multiplied 
	by the value -1, for the sake of exposition).
	
 -> Remark 1: Since the function f(y) = y*y + 3*y + 1 is not constrained (apart from
    the easy box constraints -10 <= y <= 10 which are left in the CGMP) the oracle
    only provides optimality cuts in this example.
	
 -> Remark 2: Given a dual solution y_k, the value -f(y_k) - w_k is the relative cost 
    of the generated column, where w_k is the dual solution associated to the convexity 
    constraint. Indeed, the relative cost is given by:
	        
            -c_k - s(y_k) * y_k - 1 * w_k, 
	
    By replacing c_k in the above expression we obtain:
	
            -f(y_k) + s(y_k) * y_k - s(y_k) * y_k - 1 * w_k = -f(y_k) - w_k.
	
 -> Remark 3: The optimal value of f(y) = y*y + 3*y + 1, with -10 <= y <= 10, 
    is f(y_opt) = -1.25, with unique solution y_opt = -1.5. 
	
*/

/* Bring in standard C library headers */
#include <stdlib.h>
#include <stdio.h>

/* Bring in the PDCGM/HOPDM library headers */
#include "pdcgm_SMatrix.h"
#include "pdcgm_env.h"

/* ORACLE FUNCTION: Evaluate f(y) = min{ y*y + 3*y + 1 } for a given point y */
/* The oracle() procedure must return which of the following elements was generated:
   0 -> nothing was generated, 1 -> one or more columns, 2 -> one or more valid inequalities */
static short oracle(
    double *primal_violation, 	/* total violation of the generated constraints (not used in this example) */
    double *dual_violation, 	/* total violation of the generated columns (the value f(y)) */
  	PDCGM_env  &PDCGM_env,			/* PDCGM environment */
    void   *instance_data)   	/* instance data (not used in this example) */
{

    /* Auxiliary variables for computing the cost coefficient */
    double f_value, f_derivative, cost;

    /* Dual solution vector y */
    std::vector<double> y;

    /* Auxiliary vector to store the generated column */
    /* It is a dense array with three entries: [-s(y), 1, cost]^t */
	std::vector<double> column;
    column.reserve(3);

    /* Print a message to the user */
    printf("[PDCGM] Hello from the Oracle function\n"); 

    /* Get a pointer to the dual solution of the current master problem */
    y = PDCGM_env.PDCGM_get_dual();
    
    /* Compute f(y) */
    f_value = y[0] * y[0] + 3.0 * y[0] + 1.0;
    *dual_violation = -f_value - y[1];
    
    /* Compute the cost of the column: c = f(y) - s(y) * y (see comments above) */ 
    f_derivative = 2.0 * y[0] + 3.0; 
    cost = f_value - f_derivative * y[0];
    printf("--> y = (%.6e, %.6e), f(y)= %.6e, f'(y)= %.6e, cost = %.6e\n", y[0], y[1], f_value, f_derivative, cost);
    
    /* Set the new column: [s(y), 1, -cost]^t */
    column.push_back(-cost);
    column.push_back(f_derivative);
    column.push_back(1.0);

    /* Add the new column to the current master problem */
    PDCGM_env.PDCGM_add_dense_columns(column, 3, 1);

    
    /* Return 1: a column was generated */ 
    return 1;
}

/* C MAIN FUNCTION */
int main(void)
{
    int    k, ret; /* auxiliary variables */
    
    long   dim = 1, /* number of linking constraints in the master problem */
           nb_cvxty_constr = 1, /* number of convexity constraints in the master problem */
           max_n_cols_oracle = 1, /* maximum number of columns that are generated in each call to the oracle */
           max_outer = 1000; /* maximum number of outer iterations */
    
    double delta = 1.e-6, /* optimality tolerance */
            *y0; /* RHS, initial guess, and bounds */

    std::vector<double> b;
    std::vector<double> lo_box;
    std::vector<double> up_box;
    std::vector<char> row_type;

    std::vector<double> y_opt;

    y0 = PDCGM_ALLOC(double,dim+nb_cvxty_constr);

    b.reserve(dim + nb_cvxty_constr + 1);
    lo_box.reserve(dim);
    up_box.reserve(dim);
    row_type.reserve(dim+nb_cvxty_constr);
    
    PDCGM_env PDCGM_env; /* data structure of PDCGM */
    
    /* Set the data of the linking constraint and the corresponding dual variable */
    for(k=0; k < dim; k++) 
    {
        b.push_back(0.0);
        y0[k] = 1.0; /* y0 = 1.0 is the initial guess */
        row_type.push_back('=');
        lo_box.push_back(-10.0);
        up_box.push_back(10.0);
    }
    /* Set the data of the convexity constraint and the corresponding dual variable */
    for (k=dim; k < dim + nb_cvxty_constr; k++) 
    {
        b.push_back(1.0);
        y0[k] = 0.0;
        row_type.push_back('=');
    }

    /* POPULATE THE INTERNAL DATA STRUCTURE OF PDCGM */	
	ret = PDCGM_env.PDCGM_set_data( 
        dim,  /* number of kept constraints in the RMP */
        nb_cvxty_constr,  /* number of convexity constraints in the RMP */
        (dim + nb_cvxty_constr),  /* maximum number of nonzeros in a column */
        max_n_cols_oracle,    /* maximum number of columns generated by the oracle */
        max_outer,     /* maximum number of outer iterations */
        y0, /* initial guess of the dual solution (may be NULL) */
        b,  /* RHS of each constraint in the RMP */
        row_type, /* type of each constraint (row) in the RMP */
        lo_box,   /* lower bound vector of the DUAL variables in the RMP */
        up_box,   /* upper bound vector of the DUAL variables in the RMP */
        NULL);   /* instance data */
	 			
	/* Check if the PDCGM environment was created successfully */
	if(ret)   
	{
	    printf("-- ERROR: PDCGM_set_data() returned NULL --\n");
	    fflush(stdout);
	    return 0;
	}
			
	/* Set the optimality tolerance for the column generation algorithm */
	PDCGM_env.PDCGM_set_delta(delta);   
	 
	/* Set the degree of optimality (parameter D > 1) */
    PDCGM_env.PDCGM_set_degree_of_optimality(5.0);
    
    /* Set the verbose mode (how much information is printed) */
    PDCGM_env.PDCGM_set_verbosity(1);
    
    /* Enable column elimination on insertion */
    PDCGM_env.PDCGM_set_column_elimination(1);

	/* CALL THE COLUMN GENERATION PROCEDURE */
	ret = PDCGM_env.PDCGM_solve_MP(oracle);
	
    /* Printf the optimal solution */
    printf("\nPDCGM_solve_MP() ends with code = %d\n\n", ret);
    y_opt = PDCGM_env.PDCGM_get_dual();
    for (k=0; k < dim; k++) printf("y_opt[%d] = %.6f\n", k, y_opt[k]);
    printf("Optimal value: %.6f\n\n", -PDCGM_env.PDCGM_get_obj_UB());

    /* Clean the memory before returning */
	PDCGM_env.PDCGM_free();
	
	return 0;
}
